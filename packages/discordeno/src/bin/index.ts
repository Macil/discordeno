import { Command } from 'commander'
import { createWriteStream } from 'node:fs'
import transformers, { type TransformerObjectProprieties, type TransformerUnionTypes } from './transformers.js'

const program = new Command()

program.name('discordeno').description('CLI to discordeno utilities').version('0.1.0')

testDesiredProprieties('unionNever')

program
  .command('generate')
  .description('Generate types/schema for discordeno')
  .action(async () => {
    const file = createWriteStream('transformers.generated.ts', { encoding: 'utf-8' })

    file.write('/* eslint-disable */\n')
    file.write('/* prettier-ignore */\n')
    file.write('// <auto-generated/>\n\n')

    for (const structure of Object.values(transformers)) {
      file.write(parseComment(structure.comment, 0))

      // If there aren't any proprieties for this transformer export the type as an object.
      // Using an empty interface would mean `NonNullable<unknown>` for typescript, so it would look like this: `string | number | bigint | object | ...`
      if (Object.values(structure.proprieties).length === 0) {
        file.write(`export type ${structure.name} = object\n\n`)
        continue
      }

      file.write(`export interface ${structure.name} ${parseProprietyType(structure.proprieties)}\n\n`)
    }

    file.close()
  })

program.parse()

function parseProprietyType(
  prop: TransformerObjectProprieties['type'] | TransformerUnionTypes,
  { intent, isUnion }: ParseProprietyOptions = {},
): string {
  if (typeof prop === 'string') return prop

  intent ??= 2
  isUnion ??= false

  const spaces = ' '.repeat(intent)

  if (Array.isArray(prop)) {
    return prop.map((x) => parseProprietyType(x, { intent, isUnion: true })).join(' | ')
  }

  if (isUnion) {
    const unionObject = prop as TransformerUnionTypes

    return unionObject.array
      ? `Array<${parseProprietyType(unionObject.type, { intent: intent + 2 })}>`
      : parseProprietyType(unionObject.type, { intent: intent + 2 })
  }

  const proprieties = prop as Record<string, TransformerObjectProprieties>

  let result = '{\n'

  for (const [propName, prop] of Object.entries(proprieties)) {
    result += parseComment(prop.comment, intent)

    const type = prop.array
      ? `Array<${parseProprietyType(prop.type, { intent: intent + 2 })}>`
      : parseProprietyType(prop.type, { intent: intent + 2 })

    result += `${spaces}${propName}${prop.optional ? '?' : ''}: ${type}\n`
  }

  result += `${' '.repeat(intent - 2)}}`

  return result
}

function parseComment(commentLines?: string[], intent = 2): string {
  if (!commentLines || commentLines.length === 0) return ''

  const spaces = ' '.repeat(intent)

  const comment = commentLines.reduce((prev, cur) => `${prev}${spaces} * ${cur}\n`, '')

  return `${spaces}/**\n${comment}${spaces} */\n`
}

interface ParseProprietyOptions {
  intent?: number
  isUnion?: boolean
}

// TEST FUNCTIONS

// FIXME: for now this function will disable every propriety, including getters, we don't want that
// TODO: source the desiredProprieties from somewhere
function testDesiredProprieties(mode: 'delete' | 'typeOptional' | 'typeNever' | 'unionNever'): void {
  for (const structure of Object.values(transformers)) {
    structure.comment ??= []
    structure.comment.push(
      '@remarks',
      "Some (or all) of the proprieties in this transformer have been disabled by the desiredProprieties feature. At runtime they won't have a value.",
      'To enable these propriety you need to update your desiredProprieties configuration and re-generate the typings',
    )

    for (const name of Object.keys(structure.proprieties)) {
      if (mode === 'delete') {
        Reflect.deleteProperty(structure.proprieties, name)
        continue
      }

      const prop = structure.proprieties[name]

      prop.comment ??= []
      prop.comment.push(
        '@remarks',
        'This propriety has been disabled via desiredProprieties. At runtime this will not a value unless you update your desiredProprieties configuration',
      )

      if (mode === 'typeOptional') {
        prop.optional = true
        continue
      }

      if (mode === 'typeNever') {
        prop.type = 'never'
        continue
      }

      if (mode === 'unionNever') {
        if (!Array.isArray(prop.type)) {
          if (typeof prop.type === 'string') prop.type = [prop.type]
          else prop.type = [{ type: prop.type, array: prop.array }]
        }

        prop.type.push('never')
        continue
      }
    }
  }
}
