import { Command } from 'commander'
import { createWriteStream } from 'node:fs'
import transformers, { type TransformerObjectProprieties, type TransformerUnionTypes } from './transformers.js'

const program = new Command()

program.name('discordeno').description('CLI to discordeno utilities').version('0.1.0')

if (process.env.TESTING_DISABLE_DESIRED_PROPRIETIES !== 'true') {
  testDesiredProprieties('unionNever')
  checkForProprietyDependencies('unionNever')
}

program
  .command('generate')
  .description('Generate types/schema for discordeno')
  .action(async () => {
    const file = createWriteStream('../bot/src/transformers/transformers.test.generated.ts', { encoding: 'utf-8' })

    file.write('/* eslint-disable */\n')
    file.write('/* prettier-ignore */\n')
    file.write('// <auto-generated/>\n\n')

    for (const structure of Object.values(transformers)) {
      file.write(parseComment(structure.comment, 0))

      // If there aren't any proprieties for this transformer export the type as an object.
      // Using an empty interface would mean `NonNullable<unknown>` for typescript, so it would look like this: `string | number | bigint | object | ...`
      if (Object.values(structure.proprieties).length === 0) {
        file.write(`export type ${structure.name} = object\n\n`)
        continue
      }

      file.write(`export interface ${structure.name} ${parseProprietyType(structure.proprieties)}\n\n`)
    }

    file.close()
  })

program.parse()

function parseProprietyType(
  prop: TransformerObjectProprieties['type'] | TransformerUnionTypes,
  { intent, isUnion }: ParseProprietyOptions = {},
): string {
  if (typeof prop === 'string') return prop

  intent ??= 2
  isUnion ??= false

  const spaces = ' '.repeat(intent)

  if (Array.isArray(prop)) {
    return prop.map((x) => parseProprietyType(x, { intent, isUnion: true })).join(' | ')
  }

  if (isUnion) {
    const unionObject = prop as TransformerUnionTypes

    return unionObject.array
      ? `Array<${parseProprietyType(unionObject.type, { intent: intent + 2 })}>`
      : parseProprietyType(unionObject.type, { intent: intent + 2 })
  }

  const proprieties = prop as Record<string, TransformerObjectProprieties>

  let result = '{\n'

  for (const [propName, prop] of Object.entries(proprieties)) {
    result += parseComment(prop.comment, intent)

    const type = prop.array
      ? `Array<${parseProprietyType(prop.type, { intent: intent + 2 })}>`
      : parseProprietyType(prop.type, { intent: intent + 2 })

    result += `${spaces}${propName}${prop.optional ? '?' : ''}: ${type}\n`
  }

  result += `${' '.repeat(intent - 2)}}`

  return result
}

function parseComment(commentLines?: string[], intent = 2): string {
  if (!commentLines || commentLines.length === 0) return ''

  const spaces = ' '.repeat(intent)

  const comment = commentLines.reduce((prev, cur) => `${prev}${spaces} * ${cur}\n`, '')

  return `${spaces}/**\n${comment}${spaces} */\n`
}

interface ParseProprietyOptions {
  intent?: number
  isUnion?: boolean
}

// TEST FUNCTIONS

// FIXME: for now this function will disable every propriety, including getters, we don't want that
// TODO: source the desiredProprieties from somewhere
function testDesiredProprieties(mode: 'delete' | 'typeOptional' | 'typeNever' | 'unionNever'): void {
  for (const structure of Object.values(transformers)) {
    if (structure.withoutDesiredProprietySupport) continue

    structure.comment ??= []
    structure.comment.push(
      '@remarks',
      "Some (or all) of the proprieties in this transformer have been disabled by the desiredProprieties feature. At runtime they won't have a value.",
      'To enable these propriety you need to update your desiredProprieties configuration and re-generate the typings',
    )

    for (const [key, prop] of Object.entries(structure.proprieties)) {
      if (!!prop.alwaysPresent || !!prop.dependencies) continue

      if (mode === 'delete') {
        Reflect.deleteProperty(structure.proprieties, key)
        continue
      }

      prop.comment ??= []
      prop.comment.push(
        '@remarks',
        'This propriety has been disabled via desiredProprieties. At runtime this will not a value unless you update your desiredProprieties configuration',
      )

      if (mode === 'typeOptional') {
        prop.optional = true
        continue
      }

      if (mode === 'typeNever') {
        prop.type = 'never'
        continue
      }

      if (mode === 'unionNever') {
        if (!Array.isArray(prop.type)) prop.type = [{ type: prop.type, array: prop.array }]

        prop.type.push('never')
        continue
      }
    }
  }
}

function checkForProprietyDependencies(mode: 'delete' | 'typeOptional' | 'typeNever' | 'unionNever'): void {
  for (const structure of Object.values(transformers)) {
    if (structure.withoutDesiredProprietySupport) continue

    for (const [key, prop] of Object.entries(structure.proprieties)) {
      if (!prop.dependencies) continue

      // TODO: Replace function with a proper lookup on the desiredProprieties list (when implemented). Related to the FIXME below, and TODO in testDesiredProprieties
      const areDependenciesEnabled = prop.dependencies.every((dep) => {
        const prop = structure.proprieties[dep]

        if (!prop) {
          if (mode !== 'delete') throw new Error('The declared dependency does not exist')

          // The propriety is disabled, so deleted according to the mode
          return false
        }

        if (mode === 'typeNever') return prop.type !== 'never'

        // FIXME: Considering discord can make propriety optional according to their api responses this needs to check against the list of desiredProprieties
        if (mode === 'typeOptional') return true

        if (mode === 'unionNever' && Array.isArray(prop.type)) return !prop.type.includes('never')

        return false
      })

      if (areDependenciesEnabled) continue

      if (mode === 'delete') {
        Reflect.deleteProperty(structure.proprieties, key)
        continue
      }

      prop.comment ??= []
      prop.comment.push(
        '@remarks',
        `This propriety has been disabled via desiredProprieties. This propriety depends on ${prop.dependencies.map((x) => `{@link ${x}}`).join(', ')}. If you don't enable it's dependencies, this propriety won't have a value at runtime`,
      )

      if (mode === 'typeOptional') {
        prop.optional = true
        continue
      }

      if (mode === 'typeNever') {
        prop.type = 'never'
        continue
      }

      if (mode === 'unionNever') {
        if (!Array.isArray(prop.type)) prop.type = [{ type: prop.type, array: prop.array }]

        prop.type.push('never')
        continue
      }
    }
  }
}
