const messageTypeProps = {
  activity: `  /** Sent with Rich Presence-related chat embeds */
  activity?: {
    /** Type of message activity */
    type: MessageActivityTypes
    /** party_id from a Rich Presence event */
    partyId?: string
  }\n`,
  interaction: `  /** Sent if the message is a response to an Interaction */
  interaction?: {
    /** Id of the interaction */
    id: bigint
    /** The member who invoked the interaction in the guild  */
    member?: Member
    /** The name of the ApplicationCommand including the name of the subcommand/subcommand group */
    name: string
    /** The type of interaction */
    type: InteractionTypes
    /** The user who invoked the interaction */
    user: User
  }\n`,
  messageReference: `  /** Data showing the source of a crossposted channel follow add, pin or reply message */
  messageReference?: {
    /** id of the originating message's channel Note: channel_id is optional when creating a reply, but will always be present when receiving an event/response that includes this data model. */
    channelId?: bigint
    /** id of the originating message's guild */
    guildId?: bigint
    /** id of the originating message */
    messageId?: bigint
  }\n`,
  reactions: `  /** Reactions on this message. */
  reactions?: Array<{
    /** Whether the current user reacted using this emoji */
    me: boolean
    /** Times this emoji has been used to react */
    count: number
    /** Emoji information */
    emoji: Emoji
  }>\n`,
  stickerItems: `  /** Sent if the message contains stickers */
  stickerItems?: Array<{
    /** The id of this sticker. */
    id: bigint
    /** The name of this sticker. */
    name: string
    /** The type of this stickers format. */
    formatType: StickerFormatTypes
  }>\n`,
  applicationId: `  /** if the message is an Interaction or application-owned webhook, this is the id of the application */
  applicationId?: bigint\n`,
  attachments: `  /** Any attached files on this message. */
  attachments?: Attachment[]\n`,
  author: `  /** The author of this message (not guaranteed to be a valid user) Note: The author object follows the structure of the user object, but is only a valid user in the case where the message is generated by a user or bot user. If the message is generated by a webhook, the author object corresponds to the webhook's id, username, and avatar. You can tell if a message is generated by a webhook by checking for the webhook_id on the message object. */
  author: User\n`,
  channelId: `  /** id of the channel the message was sent in */
  channelId: bigint\n`,
  components: `  /** The components related to this message */
  components: Component[]\n`,
  content: `  /** Contents of the message */
  content: string\n`,
  editedTimestamp: `  /** The timestamp in milliseconds when this message was edited last. */
  editedTimestamp?: number\n`,
  embeds: `  /** Any embedded content */
  embeds?: Embed[]\n`,
  guildId: `  /** id of the guild the message was sent in Note: For MESSAGE_CREATE and MESSAGE_UPDATE events, the message object may not contain a guild_id or member field since the events are sent directly to the receiving user and the bot who sent the message, rather than being sent through the guild like non-ephemeral messages. */
  guildId?: bigint\n`,
  id: `  /** id of the message */
  id: bigint\n`,
  member: `  /** Member properties for this message's author Note: The member object exists in MESSAGE_CREATE and MESSAGE_UPDATE events from text-based guild channels. This allows bots to obtain real-time member data without requiring bots to store member state in memory. */
  member?: Member\n`,
  mentions: `  /** Users specifically mentioned in the message Note: The user objects in the mentions array will only have the partial member field present in MESSAGE_CREATE and MESSAGE_UPDATE events from text-based guild channels. */
  mentions?: User[]\n`,
  mentionedChannelIds: `  /** Channels specifically mentioned in this message Note: Not all channel mentions in a message will appear in mention_channels. Only textual channels that are visible to everyone in a discoverable guild will ever be included. Only crossposted messages (via Channel Following) currently include mention_channels at all. If no mentions in the message meet these requirements, this field will not be sent. */
  mentionedChannelIds?: bigint[]\n`,
  mentionedRoleIds: `  /** Roles specifically mentioned in this message */
  mentionedRoleIds?: bigint[]\n`,
  nonce: `  /** Used for validating a message was sent */
  nonce?: string | number\n`,
  type: `  /** Type of message */
  type: MessageTypes\n`,
  thread: `  /** The thread that was started from this message, includes thread member object  */
  thread?: Channel\n`,
  webhookId: `  /** If the message is generated by a webhook, this is the webhook's id */
  webhookId?: bigint\n`,
}

export const messageTypeGenerator = (desiredProps: Array<keyof typeof messageTypeProps>): string => {
  let generatedMessageType = `import type { DiscordMessage, InteractionTypes, MessageActivityTypes, MessageTypes, StickerFormatTypes } from '@discordeno/types'
import { CHANNEL_MENTION_REGEX } from '../constants.js'
import { snowflakeToTimestamp, type Bot } from '../index.js'
import { MessageFlags } from '../typings.js'
import type { Attachment } from './attachment.js'
import type { Channel } from './channel.js'
import type { Component } from './component.js'
import type { Embed } from './embed.js'
import type { Emoji } from './emoji.js'
import type { Member } from './member.js'
import { ToggleBitfield } from './toggles/ToggleBitfield.js'
import type { User } from './user.js'

export interface MessageBase {
  /** Holds all the boolean values on this message. */
  bitfield?: ToggleBitfield
  /** Whether this message has been published to subscribed channels (via Channel Following) */
  crossposted: boolean
  /** Whether this message is only visible to the user who invoked the Interaction */
  ephemeral: boolean
  /** Whether this message failed to mention some roles and add their members to the thread */
  failedToMentionSomeRolesInThread: boolean
  /** Message flags combined as a bitfield */
  flags?: ToggleBitfield
  /** Whether this message has an associated thread, with the same id as the message */
  hasThread: boolean
  /** Whether this message originated from a message in another channel (via Channel Following) */
  isCrosspost: boolean
  /** Whether this message is an Interaction Response and the bot is "thinking" */
  loading: boolean
  /** The ids of the users who were mentioned in this message. */
  mentionedUserIds: bigint[]
  /** Whether this message mentions everyone */
  mentionEveryone: boolean
  /** Whether this message is pinned */
  pinned: boolean
  /** Whether the source message for this crosspost has been deleted (via Channel Following) */
  sourceMessageDeleted: boolean
  /** Whether do not include any embeds when serializing this message */
  suppressEmbeds: boolean
  /** Whether this message will not trigger push and desktop notifications */
  suppressNotifications: boolean
  /** The timestamp in milliseconds when this message was created */
  timestamp: number
  /** Whether this was a TTS message. */
  tts: boolean
  /** Whether this message came from the urgent message system */
  urgent: boolean
}

export interface Message extends MessageBase {\n`
  desiredProps.forEach((desiredProp) => (generatedMessageType += messageTypeProps[desiredProp]))
  generatedMessageType += `}\n`
  return generatedMessageType
}
